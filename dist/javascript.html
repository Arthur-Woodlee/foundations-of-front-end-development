<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>JavaScript Foundations</title>
<script defer src="javascript.18eeb9974ccec537b622.js"></script><link href="javascript.561a05c0b76d5b07bac8.css" rel="stylesheet"></head>
<body>
    <header class="header">
        <h1 class="header__title">JavaScript Foundations</h1>
    </header>
 <main class="book">
        <section id="module-patterns" class="chapter">
            <h2>JavaScript Module Patterns</h2>

            <article class="chapter__section">
                <h3>Closures (Module Pattern)</h3>
                <p>
                    Encapsulate private state using function scope.
                </p>

<pre>
    <code>
    function closure() {
        let count = 0; // private
        return {
            increment() { count++; },
            getCount() { return count; }
        };
    }
    </code>
</pre>

                <ul class="module-summary">
                    <li>‚úÖ Private variables</li>
                    <li>‚úÖ Controlled public API</li>
                    <li>
                        ‚ùå No inheritance or extensibility ‚Äî but ‚úÖ supports composition for modular reuse
                    </li>
                </ul>
            </article>

            <article class="chapter__section">
                <h3>Object Literals</h3>
                <p>
                    Simple, declarative structure for grouping related properties and methods.
                </p>

                <pre>
<code>
const logger = {
    level: 'info',
    log(message) {
        console.log('[${this.level}] ${message}');
    }
};
</code>
                </pre>

                <ul class="module-summary">
                    <li>‚úÖ Easy to read and write</li>
                    <li>‚ùå No private state</li>
                    <li>‚ö†Ô∏è No built-in inheritance ‚Äî but can be
                        extended via Object.create() (prototype delegation)</li>
                </ul>
            </article>

            <article class="chapter__section">
                <h3>Prototypal Inheritance</h3>
                <p>
                    Use <code>Object.create()</code> or constructor functions to share behavior.
                </p>

<pre>
    <code>
    const animal = {
        speak() { console.log('generic sound'); }
    };

    const dog = Object.create(animal);
    dog.speak(); // "generic sound"
    </code>
</pre>

<pre>
    <code>
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.speak = function () {
        console.log('${this.name} makes a sound');
    };
    </code>
</pre>

                <ul class="module-summary">
                    <li>‚úÖ Shared behavior via prototype chain</li>
                    <li>‚úÖ Memory-efficient</li>
                    <li>‚ùå More verbose than classes</li>
                </ul>
            </article>

            <article class="chapter__section">
                <h3>ES6 Classes</h3>
                <p>
                    Syntactic sugar over prototypal inheritance.
                </p>

<pre>
    <code>
    class User {
    constructor(name) {
        this.name = name;
    }
    greet() {
        console.log(`Hello, ${this.name}`);
    }
    }
    </code>
</pre>

                <ul class="module-summary">
                    <li>‚úÖ Clear syntax</li>
                    <li>‚úÖ Supports inheritance
                        (<code>extends</code>)</li>
                    <li>‚úÖ Works well with modern tooling</li>
                    <li>‚ùå No true private fields (until
                        <code>#private</code> syntax)
                    </li>
                </ul>
            </article>
            <article class="chapter__section">
                <h3>Modules Summary</h3>
                <p>
                    ES6 modules provide encapsulation by scoping variables and objects to the module context. When
                    combined with class <code>#private</code> fields, they offer strong privacy ‚Äî unless objects are
                    explicitly exposed to the global scope.
                </p>

                <section>
                    <h4>Closure (Module Pattern)</h4>
                    <p>Encapsulates private state using function scope.</p>
                    <ul class="module-summary">
                        <li>‚úÖ Private variables via closure</li>
                        <li>‚úÖ Controlled public API</li>
                        <li>‚úÖ Hidden from DevTools unless exposed</li>
                        <li>‚úÖ Runtime-enforced privacy</li>
                    </ul>
                </section>

                <section>
                    <h4>Object Literal</h4>
                    <p>Simple structure for grouping related properties and methods.</p>
                    <ul class="module-summary">
                        <li>‚ùå No private state</li>
                        <li>‚úÖ Easy to inspect and modify</li>
                        <li>‚ö†Ô∏è Can be extended via <code>Object.create()</code></li>
                        <li>‚ùå No runtime privacy</li>
                    </ul>
                </section>

                <section>
                    <h4>Prototypal Inheritance</h4>
                    <p>Shares behavior via prototype chain.</p>
                    <ul class="module-summary">
                        <li>‚ùå No private state</li>
                        <li>‚úÖ Memory-efficient</li>
                        <li>‚úÖ Shared behavior</li>
                        <li>‚ùå Fully inspectable in DevTools</li>
                    </ul>
                </section>

                <section>
                    <h4>ES6 Class</h4>
                    <p>Syntactic sugar over prototypal inheritance.</p>
                    <ul class="module-summary">
                        <li>‚úÖ Clear syntax</li>
                        <li>‚úÖ Supports <code>extends</code> inheritance</li>
                        <li>‚ö†Ô∏è <code>#private</code> fields are syntax-enforced only</li>
                        <li>‚ùå DevTools can inspect the instance</li>
                        <li>‚ùå Not runtime-enforced</li>
                    </ul>
                </section>

                <section>
                    <h4>ES6 Module + Class</h4>
                    <p>Combines module scope with class privacy.</p>
                    <ul class="module-summary">
                        <li>‚úÖ Strong privacy boundary</li>
                        <li>‚úÖ <code>#private</code> fields + module scope</li>
                        <li>‚úÖ Hidden unless explicitly exported</li>
                        <li>‚úÖ Runtime-enforced object privacy</li>
                        <li>‚ö†Ô∏è Attaching to <code>window</code> breaks encapsulation</li>
                    </ul>
                </section>

                <section>
                    <h4>Debugging Exposure</h4>
                    <p>During development, you may want to inspect internal objects in DevTools. This can be done safely
                        using conditional exposure:</p>
<pre>
    <code>
    const ENV = 'development';

    if (ENV === 'development') {
    window.secretInstance = secretInstance;
    console.log('üîç Exposed for debugging');
    }
    </code>
</pre>
                    <ul>
                        <li>‚úÖ Enables inspection during development</li>
                        <li>‚úÖ Keeps production scope clean</li>
                        <li>‚ö†Ô∏è Avoid exposing sensitive logic or state</li>
                    </ul>
                </section>

                <p>
                    ‚ö†Ô∏è Avoid attaching internal objects to <code>window</code> unless explicitly needed for debugging.
                    In production, this breaks encapsulation and undermines privacy guarantees.
                </p>
            </article>
        </section>
    </main>
   <footer class="footer">
    <p class="footer__text">¬© 2025 Arthur Woodlee.</p>
  </footer>
</body>
</html>